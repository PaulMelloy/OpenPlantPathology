---
title: "Measuring plant disease severity using the pliman R package"
description: |
  pliman, short for PLant IMage ANalysis, is an R package dedicated to the analysis of images of plants, mainly leaves. Among several functionalities, pliman offers a function for measuring plant disease severity. In this post I will demonstrate the process for the analysis of single images or batch processing images with soybean rust symptoms as a case study. 
draft: FALSE
author:
  - name: Emerson Del Ponte
    url: https://twitter.com/emdelponte
date: 05-31-2021
output:
  distill::distill_article:
    self_contained: false
bibliography: references.bib
preview: logo_pliman.png
---

## Introduction

In this post I will demonstrate one of the uses for [pliman](https://tiagoolivoto.github.io/pliman/), a new R package that provides a suite of functions for conducting several analysis on images of plants, especially leaves. For obvious reasons, I was greatly interested in testing a function that allows measuring plant disease severity - or the percent leaf area affected.

More than two dozen softwares, most of them proprietary, have been used for measuring percent severity in phytopathometry research [@Del2017]. Thus far, none have been made available as a specialized R package or one with dedicated functions for facilitating severity measurement.

The availability of such tools is of great importance mainly for research purposes or situations when the most accurate disease severity is necessary [@bock2020a]. Examples include the development of standard area diagrams (set of images of leaves with known severity) as well as for the validation of the tool. In the case images are obtained under standardized conditions (light and background), batch processing of images, using the same color palettes (for healthy and diseased pixels) can greatly speed up and automate the process.

Here, I will demonstrate how to measure severity using the `sympmatic_area()` function of pliman to measure severity in 10 leaves (batch processing) of soybean rust. I will also compare the measures with ones determined using Quant software used in a previous work [@franceschi2020]

## What is healthy and diseased?

The most critical is the initial step when the user needs to set the color palettes as images representing each of three classes named background (b), symptomatic (s) and healthy (h). This can be done simply by sampling small areas of the image and producing a composite image. Note: depending on how these templates are set, results can vary significantly. The observation of the processed masks becomes important to more correctly create the palettes.

In my case, I cut and pasted sections of images of several leaves representative of each class into a Google slide. Once the palette was ready, I exported each one as a separate image PNG file (JPG also works). These were named: sbr_b.png, sbr_h.png and sbr_s.png.

![](pliman1.png)

Now that we have the image palettes, let's start working with pliman and import the image palettes into the environment for further analysis. Let's create an image object for each palette named h (healthy), s (symptoms) and b (background).

```{r}
library(pliman)
h <- image_import("sbr_h.png")
s <- image_import("sbr_s.png")
b <- image_import("sbr_b.png")
```

We can visualize the images using `image_combine()` function.

```{r}
image_combine(h, s, b, ncol = 3)
```

## Computing severity

### Single image

To determine severity in a single image (img46.png), the image file needs to be loaded and assigned to an object using the same `image_import()` function used to load the palettes for each of the predefined classes. We can then visualize the image, again using `image_combine()`.

```{r}
img <- image_import("originals/img46.png")
image_combine(img)

```

Now the fun begins when using the `symptomatic_area()` function to determine severity. Four arguments are needed, the one representing the target image and each of the three images of the color palettes. As the author of the package says "pliman will take care of all details!".

```{r}
symptomatic_area(img = img,
                 img_healthy = h,
                 img_symptoms = s,
                 img_background = b,
                 show_image = TRUE)


```

### Lots of images

That was fun, but usually we don't have a single image to process but several. It would take a longer time to process each one using the above procedure, becoming tedious.

To automate the process, pliman offers a batch processing approach. For such, instead of using `img` argument, one can use `img_pattern` and define the prefix of names of the images. In addition, we also need to define the folder where the original files are located.

If the users wants to save the processed masks, the `save_image` argument needs to be set to TRUE and the directory where the images shall be saved also informed. Check below how to process 10 images of soybean rust symptoms. The outcome is a dataframe with measures for each leaf.

```{r}
pliman <- symptomatic_area(img_pattern = "img",
                 dir_original = "originals" ,
                 dir_processed = "processed",
                 save_image = TRUE,
                 img_healthy = h,
                 img_symptoms = s,
                 img_background = b,
                 show_image = FALSE)
pliman

```

With the argument `save_image` set to TRUE, the images are all saved in the folder with the standard prefix "proc".

![](pliman2.png)

## How accurate are the measures?

These 10 images were previously processed in QUANT software for determining severity. Let's create a tibble for the image code and respective "actual" severity - assuming QUANT's measures as reference.

```{r message=FALSE, warning=FALSE}
library(tidyverse)
quant <- tribble(
  ~sample, ~actual,
   "img5",     75,
  "img11",     24,
  "img35",     52,
  "img37",     38,
  "img38",     17,
  "img46",      7,
  "img63",    2.5,
  "img67",   0.25,
  "img70",     67,
  "img75",     10
  )


```

We can now combine the two dataframes and produce a scatter plot relating the two measures.

```{r}
dat <- left_join(pliman, quant)

dat %>% 
  ggplot(aes(actual, symptomatic))+
  geom_point()+
  ylim(0,100)+
  xlim(0,100)+
  geom_abline(slope = 1, intercept = 0)+
  theme_bw()+
  labs(x = "Quant", 
       y = "pliman")
  
```

The concordance correlation coefficient is a test for agreement between two observers or methods. It is an indication of how accurate the pliman measures are compared with a standard. The coefficient is greater than 0.95, suggesting an excellent agreement!

```{r}
library(epiR)
ccc <- epi.ccc(dat$actual, dat$symptomatic)
ccc$rho.c

```
